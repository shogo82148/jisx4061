package main

import (
	"bytes"
	"encoding/csv"
	"errors"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"strconv"
	"unicode/utf8"
)

func main() {
	f, err := os.Open("table.tsv")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	p := csv.NewReader(f)
	p.Comma = '\t'

	// skip header
	_, err = p.Read()
	if err != nil {
		log.Fatal(err)
	}

	buf := new(bytes.Buffer)
	fmt.Fprintln(buf, "// Code generated by gen/main.go; DO NOT EDIT.")
	fmt.Fprintln(buf, "")
	fmt.Fprintln(buf, "package jisx4061")
	fmt.Fprintln(buf, "")
	fmt.Fprintln(buf, "var table = map[rune]attr{")

	for {
		record, err := p.Read()
		if errors.Is(err, io.EOF) {
			break
		}
		if err != nil {
			log.Fatal(err)
		}

		if len(record[0]) == 0 {
			continue
		}
		line, _ := p.FieldPos(0)

		r, n := utf8.DecodeRuneInString(record[0])
		if n != len(record[0]) {
			log.Fatalf("too many characters on line %d", line)
		}
		fmt.Fprintf(buf, "'%c': {\n", r)

		// 文字クラス
		fmt.Fprint(buf, "class: ")
		switch record[1] {
		case "スペース":
			fmt.Fprint(buf, "classSpace")
		case "記述記号":
			fmt.Fprint(buf, "classDescriptor")
		case "括弧記号":
			fmt.Fprint(buf, "classBracket")
		case "学術記号":
			fmt.Fprint(buf, "classScience")
		case "一般記号":
			fmt.Fprint(buf, "classGeneral")
		case "単位記号":
			fmt.Fprint(buf, "classUnit")
		case "アラビア数字":
			fmt.Fprint(buf, "classNumber")
		case "欧字記号":
			fmt.Fprint(buf, "classSymbol")
		case "ラテンアルファベット":
			fmt.Fprint(buf, "classAlphabet")
		case "仮名":
			fmt.Fprint(buf, "classKana")
		case "漢字":
			fmt.Fprint(buf, "classKanji")
		case "げた記号":
			fmt.Fprint(buf, "classGeta")
		default:
			log.Fatalf("unknown class %q on line %d", record[1], line)
		}
		fmt.Fprintln(buf, ",")

		// 番号
		order, err := strconv.Atoi(record[2])
		if err != nil {
			line, _ := p.FieldPos(0)
			log.Fatalf("failed to parse order on line %d: %v", line, err)
		}
		fmt.Fprintf(buf, "order: %d,\n", order)

		// ダイアクリティカルマーク
		if v := record[3]; v != "" {
			fmt.Fprint(buf, "diacriticalMark: ")
			switch v {
			case "ダイアクリティカルマークなし":
				fmt.Fprint(buf, "diacriticalMarkNone")
			case "マクロン付き":
				fmt.Fprint(buf, "diacriticalMarkMacron")
			case "サーカムフレックスアクセント付き":
				fmt.Fprint(buf, "diacriticalMarkCircumflexAccent")
			default:
				log.Fatalf("unknown diacriticalMark %q on line %d", v, line)
			}
			fmt.Fprintln(buf, ",")
		}

		// 大小
		if v := record[4]; v != "" {
			fmt.Fprint(buf, "letterCase: ")
			switch v {
			case "小文字":
				fmt.Fprint(buf, "letterCaseLower")
			case "大文字":
				fmt.Fprint(buf, "letterCaseUpper")
			default:
				log.Fatalf("unknown letterCase %q on line %d", v, line)
			}
			fmt.Fprintln(buf, ",")
		}

		// 清濁
		if v := record[5]; v != "" {
			fmt.Fprint(buf, "voiced: ")
			switch v {
			case "清音":
				fmt.Fprint(buf, "voicedUnvoiced")
			case "濁音":
				fmt.Fprint(buf, "voicedVoiced")
			case "半濁音":
				fmt.Fprint(buf, "voicedSemivoiced")
			default:
				log.Fatalf("unknown voiced %q on line %d", v, line)
			}
			fmt.Fprintln(buf, ",")
		}

		// 記号種別
		if v := record[6]; v != "" {
			fmt.Fprint(buf, "symbolType: ")
			switch v {
			case "長音記号":
				fmt.Fprint(buf, "symbolTypeLongVowel")
			case "小文字":
				fmt.Fprint(buf, "symbolTypeLower")
			case "繰返し記号":
				fmt.Fprint(buf, "symbolTypeLower")
			case "大文字":
				fmt.Fprint(buf, "symbolTypeUpper")
			default:
				log.Fatalf("unknown symbolType %q on line %d", v, line)
			}
			fmt.Fprintln(buf, ",")
		}

		// 仮名種別
		if v := record[7]; v != "" {
			fmt.Fprint(buf, "kanaType: ")
			switch v {
			case "平仮名":
				fmt.Fprint(buf, "kanaTypeHiragana")
			case "片仮名":
				fmt.Fprint(buf, "kanaTypeKatakana")
			default:
				log.Fatalf("unknown kanaType %q on line %d", v, line)
			}
			fmt.Fprintln(buf, ",")
		}

		fmt.Fprint(buf, "},\n")
	}
	fmt.Fprint(buf, "}\n")

	data, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	if err := os.WriteFile("table_gen.go", data, 0o644); err != nil {
		log.Fatal(err)
	}
}
